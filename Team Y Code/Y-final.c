#pragma config(Sensor, in1,    claw_s,         sensorPotentiometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  arms_s,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  right,          sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  left,           sensorQuadEncoder)
#pragma config(Motor,  port1,           ArmR1,         tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           ArmR2,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           ArmR3,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           ClawA,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           ClawB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           DriveL,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           DriveR,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           ArmL1,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           ArmL2,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          ArmL3,         tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

int claw_;
int lift;
int drive_l;
int drive_r;
float a_value = 0.000062;
int locked = 1285;
int opened_pos = 2300;
bool close_claw = false;
bool open_claw = false;
int arms_return = false;

//void power(int left_p, int right_p)
//{
//	bool loopback = true;
//	while(loopback == true)
//	{
//		if(SensorValue[left] - 10 < left_p < SensorValue[left] + 10 && SensorValue[right] - 10 < right_p < SensorValue[right] + 10)
//		{
//			loopback = false;
//		}
//		else
//		{
//			motor[DriveL] = (SensorValue[left] - left_p);
//			motor[DriveR] = -(SensorValue[right] - right_p);
//		}
//	}
//}

//void claw_control (int claw_)
//{
//	bool loopback2 = true	;
//	while(loopback2 == true)
//	{
//	if(SensorValue[claw_s] - 10 < claw_a < SensorValue[claw_s] + 10)
//	{
//		loopback2 = false;
//	}
//	else
//	{
//		motor[ClawA] = (SensorValue[claw_s] - claw_a)/2;
//	}
//}

void shoot (int arms, int wait, bool arms_return)
{
	bool arms_up = false;
	bool arms_done = false;

	while(arms_done == false)
	{


		if(SensorValue[arms_s] > arms && arms_up == false)
		{
			motor[ArmL1] = 127;
			motor[ArmL2] = 127;
			motor[ArmL3] = 127;
			motor[ArmR1] = 127;
			motor[ArmR2] = 127;
			motor[ArmR3] = 127;

		}
		else if(SensorValue[arms_s] < arms && arms_up == false)
		{

			motor[ArmL1] = 1;
			motor[ArmL2] = 1;
			motor[ArmL3] = 1;
			motor[ArmR1] = 1;
			motor[ArmR2] = 1;
			motor[ArmR3] = 1;
			wait10Msec(wait);
			close_claw = false;
			open_claw = true;
			wait10Msec(100);
			close_claw = false;
			open_claw = false;
			wait10Msec(wait);
			arms_up = true;


		}
		else if(arms_up == true)
		{

		}
		if(arms_return == true && arms_up == true)
		{
			if(SensorValue[arms_s] < -20 )
			{
				motor[ArmL1] = -60;
				motor[ArmL2] = -60;
				motor[ArmL3] = -60;
				motor[ArmR1] = -60;
				motor[ArmR2] = -60;
				motor[ArmR3] = -60;
			}
			else
			{
				motor[ArmL1] = 0;
				motor[ArmL2] = 0;
				motor[ArmL3] = 0;
				motor[ArmR1] = 0;
				motor[ArmR2] = 0;
				motor[ArmR3] = 0;
				arms_done = true;
			}
		}
		else if(arms_up == true && arms_return == false)
		{
			motor[ArmL1] = 0;
			motor[ArmL2] = 0;
			motor[ArmL3] = 0;
			motor[ArmR1] = 0;
			motor[ArmR2] = 0;
			motor[ArmR3] = 0;
			arms_done = true;
		}


	}
}
task claw()
{
	while(true)
	{

		if(vexRT[Btn6U] == 1 || close_claw == true)
		{
			;
			claw_ = (SensorValue[claw_s] - locked)/2;
		}
		else if(vexRT[Btn5U] == 1 || open_claw == true)
		{
			claw_ = (SensorValue[claw_s] - opened_pos);
			locked = 1000;
		}
		else if(vexRT[Btn6D] == 1)
		{
			if(SensorValue[claw_s] < locked)
			{
				claw_ = 0;
			}
			else
			{
				claw_ = (SensorValue[claw_s] - locked);
			}
		}
		else
		{
			if(vexRT[Btn7L] == 1)
			{
				claw_ = 127;
			}
			else if(vexRT[Btn7R] == 1)
			{
				claw_ = -127;
			}
			else
			{
				claw_ = 0;
			}
		}
		motor[ClawA] = claw_;
		motor[ClawB] = claw_;
	}

}
task arms()
{
	while(true)
	{

		lift = vexRT[Ch3];

		motor[ArmR1] = lift;
		motor[ArmR2] = lift;
		motor[ArmR3] = lift;
		motor[ArmL1] = lift;
		motor[ArmL2] = lift;
		motor[ArmL3] = lift;
	}
}

task drive()
{
	if(vexRT[Btn7D])
	{
		a_value = 0.000042;
	}
	else
	{
		a_value = 0.000062;
	}

	while(true)
	{
		int x_axis = (a_value * (vexRT[Ch1]* vexRT[Ch1]* vexRT[Ch1]));
		int y_axis = (a_value * (vexRT[Ch2]* vexRT[Ch2]* vexRT[Ch2]));
		drive_l = (y_axis - x_axis); //converts x and y axis to left motor power
		drive_r = (y_axis + x_axis);
		motor[DriveL] = drive_l;
		motor[DriveR] = drive_r;
	}
}

void drive_s(int dist)
{
	bool drive_a_ = true;
	SensorValue[right] = 0;
	int tol_da = 25;
	int counter_d = 0;
	int counter_d_2 = 0;

	while(drive_a_ == true)
	{
		if(dist == -400)
		{
			SensorValue[dgtl10] = 1;
		}
		else
		{
			SensorValue[dgtl10] = 0;
		}
		if(counter_d > 150)
		{
			motor[DriveL] = 0;
			motor[DriveR] = 0;

			drive_a_ = false;

		}
		if(dist + tol_da > SensorValue[right] && dist - tol_da < SensorValue[right])
		{
			counter_d ++;
			counter_d_2 = 0;
		}

		else
		{
			counter_d_2 ++;
			int motorpower;
			motorpower = (SensorValue[right] - dist)* 0.55;
			if(motorpower < tol_da && motorpower > -tol_da && motorpower != 0)
			{
				motorpower = 0;
			}
			motor[DriveL] = motorpower + motorpower*(counter_d_2/200);

			motor[DriveR] = motorpower + motorpower*(counter_d_2/200);

		}

	}
}
void drive_t(int time, int power)
{
	motor[DriveL] = power;
	motor[DriveR] = power;
	wait10Msec(time);
	motor[DriveL] = 0;
	motor[DriveR] = 0;

}
void gyro_turn(int angle)
{
	int motorpower = 1;
	bool turned = false;
	int i;
	int tol_gyro = 20;
	int counter_g;
	SensorValue[in3] = 0;
	while(turned == false)
	{
		if(motorpower == 0)
		{

			turned = true;

		}
		else
		{

			counter_g ++;
			motorpower = (SensorValue[in3] - angle)*0.55;
			if(motorpower < 25 &&  motorpower > -25 && motorpower != 0)
			{
				motorpower = 0;
				counter_g = 0;
			}
			motor[DriveL] = -motorpower - motorpower*(counter_g/200);
			motor[DriveR] = motorpower + motorpower*(counter_g/200);

		}


	}
}
task autonomous()
{
	int kill = false
	int auton_s = 2;
	while(auton_s == 1 && kill == false)
	{
		startTask(claw);
		shoot(-100,10,true);
		drive_t(60,127);
		gyro_turn(-750);
		close_claw = false;
		open_claw = true;
		drive_t(100,127);
		close_claw = true;
		open_claw = false;
		gyro_turn(-800);
		drive_t(70,-127);
		arms_return = false;
		shoot(-1000,10,false);
		kill = true;
	}
	while(auton_s == 2 && kill == false)
	{
		startTask(claw);
		drive_t(60,127);
		gyro_turn(-750);
		close_claw = false;
		open_claw = true;
		drive_t(100,127);
		close_claw = true;
		open_claw = false;
		gyro_turn(-800);
		drive_t(70,-127);
		arms_return = false;
		shoot(-1000,10,true);
		close_claw = false;
		open_claw = true;
		drive_t(150,127);
		close_claw = true;
		open_claw = false;
		drive_t(150,-127);
		shoot(-1000,10,true);
		kill = true;
	}


}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	while(true)
	{
		close_claw = false;
		open_claw = false;
		startTask(claw);
		startTask(arms);
		startTask(drive);

	}

}
