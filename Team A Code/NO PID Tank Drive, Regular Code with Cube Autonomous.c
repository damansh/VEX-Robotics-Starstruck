#pragma config(Sensor, in8,    clawPotentiometer, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  armShaft,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  driveLeftShaft, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  driveRightShaft, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  clawShaft,      sensorQuadEncoder)
#pragma config(Motor,  port1,           armRightBottom, tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           armRightMiddle, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           armRightTop,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           armLeftMiddle, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           armLeftTop,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           clawA,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           clawB,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           Left,          tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port9,           Right,         tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          armLeftBottom, tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/


// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

#pragma autonomousDuration(15)
#pragma userControlDuration(120)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

void autoDrive(int speed) {
	motor[driveLeft] = speed;
	motor[driveRight] = speed;
}

void autoDriveTicks(int speed, int ticks) {
	while(SensorValue[driveRightShaft] < ticks) {
		autoDrive(speed);
	}
	autoDrive(0);
}

void autoArmUp() {
	SensorValue[armShaft] = 0;
	while(SensorValue[armShaft] < 50) {
		motor[armLeftTop] = 70;
		motor[armLeftMiddle] = 70;
		motor[armLeftBottom] = 70;
		motor[armRightTop] = 70;
		motor[armRightMiddle] = 70;
		motor[armRightBottom] = 70;
	}
	SensorValue[armShaft] = 0;
	motor[armLeftTop] = 0;
	motor[armLeftMiddle] = 0;
	motor[armLeftBottom] = 0;
	motor[armRightTop] = 0;
	motor[armRightMiddle] = 0;
	motor[armRightBottom] = 0;
}

void autoArmDown() {
	SensorValue[armShaft] = 0;
	while(SensorValue[armShaft] > 10) {
		motor[armLeftTop] = -30;
		motor[armLeftMiddle] = -30;
		motor[armLeftBottom] = -30;
		motor[armRightTop] = -30;
		motor[armRightMiddle] = -30;
		motor[armRightBottom] = -30;
	}
	SensorValue[armShaft] = 0;
}

void autoArmStop() {
	motor[armLeftTop] = 0;
	motor[armLeftMiddle] = 0;
	motor[armLeftBottom] = 0;
	motor[armRightTop] = 0;
	motor[armRightMiddle] = 0;
	motor[armRightBottom] = 0;
}

void autoClawOpen() {
	while (SensorValue[clawPotentiometer] > 10) {
		motor[clawA] = 50;
		motor[clawB] = 50;
	}
}

void autoClawWide() {
	while (SensorValue[clawPotentiometer] < 2200) {
		motor[clawA] = -50;
		motor[clawB] = -50;
	}
	motor[clawA] = 0;
	motor[clawB] = 0;
}

void autoClawClose() {
	while (SensorValue[clawPotentiometer] < 10) {
		motor[clawA] = -50;
		motor[clawB] = -50;
	}
}

void autoClawStop() {
	motor[clawA] = 0;
	motor[clawB] = 0;
}

void allStop() {
	autoDrive(0);
	autoArmStop();
	autoClawStop();
}

void autoDriveTicksShaft(int masterPower, int ticks) {
	int totalTicks = 0;
	int Autoerror = 0;
	int slavePower = masterPower - 5;

	SensorValue[driveRightShaft] = 0;
	SensorValue[driveLeftShaft] = 0;

	while(abs(totalTicks) < ticks) {
		motor[Left] = masterPower;
		motor[Right] = slavePower;

		Autoerror = (abs(SensorValue[driveLeftShaft]) - SensorValue[driveRightShaft]);
		slavePower += Autoerror * 0.5;
		totalTicks += abs(SensorValue[driveLeftShaft]);
		SensorValue[driveRightShaft] = 0;
		SensorValue[driveLeftShaft] = 0;
		wait1Msec(100);
	}
	motor[Left] = 0;
	motor[Right] = 0;
}



void autoTurn(int ticks) {
	SensorValue[driveLeftShaft] = 0;
	while(SensorValue[driveLeftShaft] < ticks) {
		motor[Left] = -60;
		motor[Right] = 60;
	}
	motor[Left] = 0;
	motor[Right] = 0;
	SensorValue[driveLeftShaft] = 0;
}
void autoTurnCube() {
	SensorValue[driveRightShaft] = 0;
	while(SensorValue[driveRightShaft] > -1050) {
		motor[Left] = 0;
		motor[Right] = -127;
		motor[clawA] = -50;
		motor[clawB] = -50;
	}
	SensorValue[driveRightShaft] = 0;
	motor[Left] = 0;
	motor[Right] = 0;
	motor[clawA] = 0;
	motor[clawB] = 0;
}

void autoClawCompleteClose() {
	SensorValue[clawShaft] = 0;
	while (SensorValue[clawShaft] < 127) {
		motor[clawA] = -50;
		motor[clawB] = -50;
	}
	SensorValue[clawShaft] = 0;
}
void autoTurnSlow () {
	SensorValue[driveLeftShaft] = 0;
	while (SensorValue[driveLeftShaft] > -320) {
		motor[Left] = 50;
	}

}

void Cube() {
	SensorValue[armShaft] = 0;
	while(SensorValue[armShaft] < 100) {
		motor[armLeftTop] = 127;
		motor[armLeftMiddle] = 127;
		motor[armLeftBottom] = 127;
		motor[armRightTop] = 127;
		motor[armRightMiddle] = 127;
		motor[armRightBottom] = 127;
		motor[clawA] = -50;
		motor[clawB] = -50;
	}
	while(SensorValue[armShaft] < 125) {
		motor[armLeftTop] = 127;
		motor[armLeftMiddle] = 127;
		motor[armLeftBottom] = 127;
		motor[armRightTop] = 127;
		motor[armRightMiddle] = 127;
		motor[armRightBottom] = 127;
		while(SensorValue[clawShaft] > -30) {
			motor[clawA] = 50;
			motor[clawB] = 50;
		}
		while(SensorValue[clawShaft] < -30) {
			motor[clawA] = -50;
			motor[clawB] = -50;
		}
		motor[clawA] = 0;
		motor[clawB] = 0;

	}
	motor[clawA] = 0;
	motor[clawB] = 0;
	motor[armLeftTop] = 0;
	motor[armLeftMiddle] = 0;
	motor[armLeftBottom] = 0;
	motor[armRightTop] = 0;
	motor[armRightMiddle] = 0;
	motor[armRightBottom] = 0;
}

void autoDriveBack () {
	SensorValue[driveRightShaft] = 0
	while(SensorValue[driveRightShaft] > -550) {
		motor[Left] = -127;
		motor[Right} = -127;
	motor[clawA] = -50;
	motor[clawB] = -50;
}
motor[Left] = 0;
motor[Right} = 0;
}

void hang () {
SensorValue[armShaft] = 0;
while(SensorValue[armShaft] < 20) {
motor[armLeftTop] = 127;
motor[armLeftMiddle] = 127;
motor[armLeftBottom] = 127;
motor[armRightTop] = 127;
motor[armRightMiddle] = 127;
motor[armRightBottom] = 127;
}
motor[armLeftTop] = 0;
motor[armLeftMiddle] = 0;
motor[armLeftBottom] = 0;
motor[armRightTop] = 0;
motor[armRightMiddle] = 0;
motor[armRightBottom] = 0;
}





/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
 hang();
autoTurnSlow();
autoDriveTicksShaft(100,500);
autoClawCompleteClose();
autoTurnCube();
autoDriveBack();
Cube();
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
int left;
int right;
int arms;
int claw;
float target;
float error;
float integral;
float derivative;
float lastError;
float prop; //proportional
float Kp = 0.4;
float Ki = 0.3;
float Kd = 0.2;

task drive()
{
int left = 0;
int right = 0;

while(true)
{
motor[Left] = vexRT[Ch2];
motor[Right] = vexRT[Ch3];
}
}

task arm()
{
while(true) {

while (vexRT[Btn6U] == 1) {
	arms = 127;
}
while(vexRT[Btn6D] == 1) {
	arms = -127;
}
arms = 0;
}
}


task clawControl()
{
while(true) {
while (vexRT[Btn5U] == 1) {
	claw = -50;
}

while (vexRT[Btn5D] == 1) {
	claw = 50;
}
claw = 0;
}
}


task usercontrol()
{
startTask(drive);
startTask(arm);
startTask(clawControl);

while(true)
{
motor[clawA] = claw;
motor[clawB] = claw;
motor[armLeftTop] = arms;
motor[armLeftMiddle] = arms;
motor[armLeftBottom] = arms;
motor[armRightTop] = arms;
motor[armRightMiddle] = arms;
motor[armRightBottom] = arms;
}
}

// PID CODE
/*		if (vexRT[Btn7R] == 1) {
target = 45;
SensorValue[armShaft] = 0;
while(vexRT[Btn6D] == 0 || vexRT[Btn6U] == 0) {
claw = 50;
error = target - SensorValue[armShaft];
integral = integral + error;

if (error == 0) {
integral = 0;
}

if (abs(error) > 50) {
integral = 0;
}

derivative = error - lastError;
lastError = error;
arms = (Kp*error) + (Ki*integral) + (Kd*derivative);
}
} */
